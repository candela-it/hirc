{% extends "base.html"%}

{% block content %}
<div class="ui one column page grid">
  <div class="column">
    {% if form.errors %}
    <div class="ui secondary inverted red segment">
    We noticed some issues. Please correct errors below.
    </div>
    {% endif %}
    <form  action="" method="post" enctype="multipart/form-data" id="new_request">{% csrf_token %}
        <div class="ui form segment">
          {% if form.status %}
          <div class="field">
            <a class="small ui secondary button" href="{% url 'view_request' object.id %}">
              <i class="block layout icon"></i> Detailed request view
              </a>
          </div>
          {% endif %}
          <div class="field">
            {{form.title.label_tag}}
            <div class="ui left labeled icon input">
                {{ form.title }}
                <i class="info letter icon"></i>
                <div class="ui corner label">
                    <i class="icon asterisk"></i>
                </div>
            </div>
            {% if form.title.errors %}
              {% for error in form.title.errors %}
              <div class="ui pointing red label">
                {{ error }}
              </div>
              {% endfor %}
            {% endif %}
          </div>
          {% if form.status %}
          <div class="field">
            <label>Status:</label>
            {% for radio in form.status %}
                <div class="ui radio checkbox">
                  {{ radio.tag }}
                  <label>{{ radio.choice_label }} </label>
                </div><br />
            {% endfor %}
          </div>
          {% endif %}
          <div class="field">
            {{form.description.label_tag}}
            <div class="ui left labeled icon input">
              {{ form.description }}
              <i class="text file icon"></i>
              <div class="ui corner label">
                <i class="icon asterisk"></i>
              </div>
            </div>
            {% if form.description.errors %}
              {% for error in form.description.errors %}
              <div class="ui pointing red label">
                {{ error }}
              </div>
              {% endfor %}
            {% endif %}
          </div>
          <div class="field">
            <label>Imagery request area of interest:</label>
            <div id="map" class="map" style="height: 450px"></div>
            {% if form.area_of_interest.errors %}
              {% for error in form.area_of_interest.errors %}
              <div class="ui pointing red label">
                {{ error }}
              </div>
              {% endfor %}
            {% endif %}
          </div>
          {{ form.area_of_interest }}
          <label>Question set:</label>
          {% for radio in form.question_set %}
            <div class="field">
              <div class="ui radio checkbox">
                {{ radio.tag }}
                <label>{{ radio.choice_label }}</label>
              </div>
            </div>
          {% endfor %}
          {% if form.question_set.errors %}
              {% for error in form.question_set.errors %}
              <div class="ui pointing red label">
                {{ error }}
              </div>
              {% endfor %}
          <br><br>
          {% endif %}
          <button class="ui right blue labeled icon button submit" type="submit"><i class="right arrow icon"></i> Submit</button>
        </div>
    </form>
  </div>
</div>
{% endblock content %}

{% block extra_js %}
  <script type="text/javascript">
    $('#menu_imagery').addClass('active');
    $('.ui.radio.checkbox')
      .checkbox()
    ;
    initMap();
    // Initialise the FeatureGroup to store editable layers


    if ( $('#id_area_of_interest').val() != '') {
      //drawnItems.clearLayers();
      polygon = $('#id_area_of_interest').val();
      // if polygon is in geojson
      if (polygon[0] == '{') {
        geojsonFeature = jQuery.parseJSON(polygon);
        var drawnItems = L.geoJson(geojsonFeature);
      } else {
        var drawnItems = omnivore.wkt.parse(polygon);
      }
      map.fitBounds(drawnItems.getBounds());
    } else {
      var drawnItems = new L.FeatureGroup();
    }
    drawnItems.on('layeradd', function() {
      map.fitBounds(drawnItems.getBounds());
    });
    map.addLayer(drawnItems);
    // Initialise the draw control and pass it the FeatureGroup of editable layers
    var drawControl = new L.Control.Draw({
      draw: {
        polygon: {
          allowIntersection: false,
          drawError: {
                    color: '#e1e100',
                    message: 'Draw normal polygons!'
                },
                shapeOptions: {
                    color: '#FFA500'
                }
        },
            polyline: false,
            rectangle: false,
            circle: false,
            marker: false,
      },
        edit: {
            featureGroup: drawnItems
        }
    });
    map.addControl(drawControl);

    // Signal if drawing is activated. Initially it's not active.
    var drawIsActive = false;
    // Signal if edition is saved. Used for draw:editstop event.
    var isEditionSaved = false;

    map.on('draw:drawstart', function (e) {
      drawIsActive = true;
    });

    map.on('draw:created', function (e) {
        var layer = e.layer;
        drawIsActive = false;
        console.log('nacrtano')

        drawnItems.addLayer(layer);

        // Layers list.
        var layers = drawnItems.getLayers();

        // Check after drawing: line segments intersection; point in another polygon;
        // polygon overlaps another polygon.
        // Important because sometimes checks during drawing are not made.
        // It can happen because sometimes map.on('click') event listener doesn't
        // "get" that click (e.g., when you draw points on map quickly).
        if (layers.length > 1) {

            var polygons = get_cleaned_polygons(layers);
            var trouble_polygons = check_after_drawing(polygons);

            if (trouble_polygons.length > 0) {
                var polygon_counter = 0;

                for (var key in drawnItems._layers) {
                    if($.inArray(polygon_counter, trouble_polygons) != -1) {
                        drawnItems._layers[key].setStyle({
                            fillColor: '#ca4c4d',
                            color: '#ca4c4d'
                        });
                    }
                    polygon_counter++;
                }
            }
        }

        // dump to textarea
        $('#id_area_of_interest').val(JSON.stringify(layer.toGeoJSON()['geometry']));

        // Set previuos_point var to null because next polygon won't have
        // previous_point immediately.
        previous_point = null;
    });

    map.on('draw:drawstop', function (e) {
      drawIsActive = false;
    });

    map.on('draw:edited', function (e) {
        // draw:edited gets called after saving edition, BUT before draw:editstop
        //(i.e. draw:editstop is called after both save and cancel edit).
        // So our custom logic that we want to implement after saving edition
        // should go in draw:editstop.

        isEditionSaved = true;
    });

    map.on('draw:editstop', function (e) {
        // If edition is saved do the checking process,
        // if not (i.e. canceled ) just pass.
        if (isEditionSaved == true) {
            // Layers list.
            var layers = drawnItems.getLayers();

            if (layers.length > 1) {
                var polygons = get_cleaned_polygons(layers);
                var trouble_polygons = check_after_drawing(polygons);

                // Set "error" color to trouble polygons and default color to
                // regular polygons.
                var polygon_counter = 0;

                for (var key in drawnItems._layers) {
                    if($.inArray(polygon_counter, trouble_polygons) != -1) {
                        drawnItems._layers[key].setStyle({
                            fillColor: '#ca4c4d',
                            color: '#ca4c4d'
                        });
                    } else {
                        // Set default color.
                        drawnItems._layers[key].setStyle({
                            fillColor: '#FFA500',
                            color: '#FFA500'
                        });
                    }
                    polygon_counter++;
                }
            }

            // layers.eachLayer(function (layer) {
            //     $('#id_area_of_interest').val(JSON.stringify(layer.toGeoJSON()['geometry']));
            // });
        }
        isEditionSaved = false;
    });

    map.on('draw:deleted', function (e) {
        var layers = e.layers;
        layers.eachLayer(function (layer) {
            $('#id_area_of_interest').val('');
        });
    });

    var previous_point = null;
    var current_point = null;

    map.on('click', function(e) {
        // If drawing is activated check if new point is inside existing polygon or
        // new line segment intersects with any of the existing line segments.
        if (drawIsActive == true) {
            current_point = [e.layerPoint.x, e.layerPoint.y];
            var layers = drawnItems.getLayers();

            // If other polygons exist then go through the checking process.
            if (layers.length > 0) {
                polygons = get_cleaned_polygons(layers)

                // Check if current point is inside existing polygon,
                // (important only for the first point of polygon).
                // For each polygon check if current line segment intersects
                // any line segement of the polygon.
                jQuery.each(polygons, function() {
                    // If previous_point exists (means that line segment exists)
                    // check intersections.
                    if (previous_point) {
                        var p1 = {x: previous_point[0], y: previous_point[1]};
                        var p2 = {x: current_point[0], y: current_point[1]};

                        for (i=0, j=this.length-1;i<this.length; j=i++) {
                            var p3 = {x: this[i][0], y: this[i][1]};
                            var p4 = {x: this[j][0], y: this[j][1]};

                            var intersects = L.LineUtil.segmentsIntersect(p1, p2, p3, p4);

                            if (intersects == true) {
                                // Programatically click link to delete the last vertex.
                                $('.leaflet-draw-actions li a:first')[0].click();
                                // Revert value of current_point to previous_point.
                                current_point = previous_point;
                                return false; // break jquery each loop and current loop
                            }
                        }
                    } else {
                        var pointIsInPolygon = point_in_polygon(current_point, this);

                        // If current point is inside existing polygon then delete
                        // that point and show error message.
                        if (pointIsInPolygon == true) {
                            // Programatically click link to delete created vertex.
                            $('.leaflet-draw-actions li a:eq(1)')[0].click();
                            return false; // break jquery each loop
                        }
                    }
                });
            }
            // Set value of previous point to current_point for future.
            previous_point = current_point;
        }
    });

    // When link for drawing polygon is clicked then add event listener for 'cancel' link.
    $('.leaflet-draw-section .leaflet-draw-toolbar a:eq(0)').on('click', function() {
          // When cancel drawing link is clicked (either programatically or manually)
          // reset value of current point and previous point.
          $('.leaflet-draw-actions li a:eq(1)').on('click', function() {
              current_point = null;
              previous_point = null;
          });
    });

    function check_after_drawing(polygons) {
        var trouble_polygons = [];

        // Check if any line segemnt of any polygon intersects with any line
        // segment of any other polygon.
        for (var i = 0, j = polygons.length - 1; i < polygons.length; j = i++) {
            var poly_a = polygons[i];
            var poly_b = polygons[j];

            for (var k = 0, h = poly_a.length - 1; k < poly_a.length; h = k++) {
                var p_1a = {x: poly_a[k][0], y: poly_a[k][1]};
                var p_2a = {x: poly_a[h][0], y: poly_a[h][1]};

                for (var e = 0, f = poly_b.length - 1; e < poly_b.length; f = e++) {
                    var p_1b = {x: poly_b[e][0], y: poly_b[e][1]};
                    var p_2b = {x: poly_b[f][0], y: poly_b[f][1]};

                    var intersects = L.LineUtil.segmentsIntersect(p_1a, p_2a, p_1b, p_2b);

                    if (intersects == true) {
                        if( $.inArray(i, trouble_polygons) == -1 ) {
                            trouble_polygons.push(i);
                        }

                        if ($.inArray(j, trouble_polygons) == -1 ) {
                                trouble_polygons.push(j);
                        }
                    }
                }
            }
            // If there are only 2 polgons, break the loop. We don't need to
            // do the process for 1st-2nd and 2nd-1st pair of polygons.
            if (polygons.length == 2) {
                break;
            }
        }

        return trouble_polygons;
    }

    function get_cleaned_polygons(layers) {
        var polygons = [];

        // For each layer (polygon) get it's points coords. in pixels.
        jQuery.each(layers, function () {
            var polygon_points = this._originalPoints;
            var clean_polygon_points = [];

            jQuery.each(polygon_points, function() {
                clean_polygon_points.push([this.x, this.y]);
            });

            polygons.push(clean_polygon_points);
        });

        return polygons;
    }

    // Function that checks if point is inside polygon.
    function point_in_polygon (point, polygon) {
        var x = point[0], y = point[1];

        var inside = false;
        for (var i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
            var xi = polygon[i][0], yi = polygon[i][1];
            var xj = polygon[j][0], yj = polygon[j][1];

            var intersect = ((yi > y) != (yj > y))
                && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
            if (intersect) inside = !inside;
        }
        return inside;
    }

  </script>
{% endblock %}