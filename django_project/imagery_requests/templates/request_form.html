{% extends "base.html"%}

{% block content %}
<div class="ui one column page grid">
  <div class="column">
    {% if form.errors %}
    <div class="ui secondary inverted red segment">
    We noticed some issues. Please correct errors below.
    </div>
    {% endif %}
    <form  action="" method="post" enctype="multipart/form-data" id="new_request">{% csrf_token %}
        <div class="ui form segment">
          {% if form.status %}
          <div class="field">
            <a class="small ui secondary button" href="{% url 'view_request' object.id %}">
              <i class="block layout icon"></i> Detailed request view
              </a>
          </div>
          {% endif %}
          <div class="field">
            {{form.title.label_tag}}
            <div class="ui left labeled icon input">
                {{ form.title }}
                <i class="info letter icon"></i>
                <div class="ui corner label">
                    <i class="icon asterisk"></i>
                </div>
            </div>
            {% if form.title.errors %}
              {% for error in form.title.errors %}
              <div class="ui pointing red label">
                {{ error }}
              </div>
              {% endfor %}
            {% endif %}
          </div>
          {% if form.status %}
          <div class="field">
            <label>Status:</label>
            {% for radio in form.status %}
                <div class="ui radio checkbox">
                  {{ radio.tag }}
                  <label>{{ radio.choice_label }} </label>
                </div><br />
            {% endfor %}
          </div>
          {% endif %}
          <div class="field">
            {{form.description.label_tag}}
            <div class="ui left labeled icon input">
              {{ form.description }}
              <i class="text file icon"></i>
              <div class="ui corner label">
                <i class="icon asterisk"></i>
              </div>
            </div>
            {% if form.description.errors %}
              {% for error in form.description.errors %}
              <div class="ui pointing red label">
                {{ error }}
              </div>
              {% endfor %}
            {% endif %}
          </div>
          <div class="field">
            <label>Imagery request area of interest:</label>
            <div id="map" class="map" style="height: 450px"></div>
            {% if form.area_of_interest.errors %}
              {% for error in form.area_of_interest.errors %}
              <div class="ui pointing red label">
                {{ error }}
              </div>
              {% endfor %}
            {% endif %}
          </div>
          {{ form.area_of_interest }}
          {{ form.multipolygon_errors }}
          <label>Question set:</label>
          {% for radio in form.question_set %}
            <div class="field">
              <div class="ui radio checkbox">
                {{ radio.tag }}
                <label>{{ radio.choice_label }}</label>
              </div>
            </div>
          {% endfor %}
          {% if form.question_set.errors %}
              {% for error in form.question_set.errors %}
              <div class="ui pointing red label">
                {{ error }}
              </div>
              {% endfor %}
          <br><br>
          {% endif %}
          <button class="ui right blue labeled icon button submit" type="submit"><i class="right arrow icon"></i> Submit</button>
        </div>
    </form>
  </div>
</div>
{% endblock content %}

{% block extra_js %}
  <script type="text/javascript">
    $('#menu_imagery').addClass('active');
    $('.ui.radio.checkbox')
      .checkbox();

    initMap();

    // Initialise the FeatureGroup to store editable layers.
    var drawnItems = new L.FeatureGroup();

    drawnItems.on('layeradd', function() {
        map.fitBounds(drawnItems.getBounds());
    });

    // If area exists (i.e. we are editing previously saved request).
    if ( $('#id_area_of_interest').val() != '') {
        var polygon = $('#id_area_of_interest').val();
        // if polygon is in geojson
        if (polygon[0] == '{') {
            var geojsonFeature = jQuery.parseJSON(polygon);
            var parsed_polygon = L.geoJson(geojsonFeature)

            // Add multipolygon parts separately to use leaflet draw features.
            jQuery.each(parsed_polygon._layers, function(index_1, obj_1) {
                jQuery.each(obj_1._layers, function(index_2, obj_2) {
                    drawnItems.addLayer(obj_2);
                });
            });
        } else {
            // polygon is in wkt.
            var parsed_polygon = omnivore.wkt.parse(polygon);
            // Add multipolygon parts separately to use leaflet draw features.
            jQuery.each(parsed_polygon._layers, function(index_1, obj_1) {
                jQuery.each(obj_1._layers, function(index_2, obj_2) {
                    drawnItems.addLayer(obj_2);
                });
            });
        }
    }

    map.addLayer(drawnItems);

    // Initialise the draw control and pass it the FeatureGroup of editable layers
    var drawControl = new L.Control.Draw({
      draw: {
        polygon: {
          allowIntersection: false,
          drawError: {
                    color: '#e1e100',
                    message: 'Draw normal polygons!'
                },
                shapeOptions: {
                    color: '#FFA500'
                }
        },
            polyline: false,
            rectangle: false,
            circle: false,
            marker: false,
      },
        edit: {
            featureGroup: drawnItems
        }
    });

    map.addControl(drawControl);

    // Initial vars for custom error tooltip.
    errorShown = false;
    custom_tooltip = null;
    hideErrorTimeout = null;

    function show_custom_tooltip(error_string) {
        // Hide error tooltip if exists.
        hideErrorTooltip();

        custom_tooltip = new L.Tooltip(map);
        custom_tooltip.updateContent({text: error_string});
        custom_tooltip.showAsError();
        errorShown = true;
        // Hide the error after 2 seconds
        hideErrorTimeout = setTimeout(L.Util.bind(hideErrorTooltip), 4000);
    }

    function hideErrorTooltip() {
        errorShown = false;
        if (custom_tooltip) {
            clearHideErrorTimeout();
            custom_tooltip.dispose();
            custom_tooltip = null;
        }
    }

    function clearHideErrorTimeout() {
        if (hideErrorTimeout) {
            clearTimeout(hideErrorTimeout);
            hideErrorTimeout = null;
        }
    }

    // Signal if drawing is activated. Initially it's not active.
    var drawIsActive = false;
    // Signal if edition is saved. Used for draw:editstop event.
    var isEditionSaved = false;
    // Initial vars for multipolygon checks during drawing.
    var previous_point = null;
    var current_point = null;

    map.on('draw:drawstart', function (e) {
      drawIsActive = true;
    });

    map.on('draw:created', function (e) {
        var layer = e.layer;
        drawIsActive = false;

        drawnItems.addLayer(layer);

        var trouble_polygons = [];
        var layers = drawnItems.getLayers();  // Layers list.

        // Check after drawing: line segments intersection; point in another polygon;
        // polygon overlaps another polygon.
        // Important because sometimes checks during drawing are not made.
        // It can happen because sometimes map.on('click') event listener doesn't
        // "get" that click (e.g., when you draw points on map quickly).
        if (layers.length > 1) {

            var polygons = get_cleaned_polygons(layers);

            var result = check_after_drawing(polygons);
            var trouble_polygons = result.trouble_polygons;
            var error_messages = result.error_messages;

            // If there are trouble polygons make them red.
            if (trouble_polygons.length > 0) {
                var polygon_counter = 0;

                for (var key in drawnItems._layers) {
                    if($.inArray(polygon_counter, trouble_polygons) != -1) {
                        drawnItems._layers[key].setStyle({
                            fillColor: '#ca4c4d',
                            color: '#ca4c4d'
                        });
                    }
                    polygon_counter++;
                }
            }
        }

        // Dump geojson to textarea.
        var geojson_string = create_geojson_multipolygon_string();
        $('#id_area_of_interest').val(geojson_string);

        if (trouble_polygons.length == 0) {
            // Empty multipolygon errors field.
            $('#id_multipolygon_errors').val('');
        } else {
            // Put multipolygon errors text in textarea.
            error_string = '';

            jQuery.each(error_messages, function() {
                error_string += this + ' ';
            });

            $('#id_multipolygon_errors').val(error_string);

            // Show error tooltip.
            show_custom_tooltip(error_string);
        }

        // Set previuos_point var to null because next polygon won't have
        // previous_point immediately.
        previous_point = null;
    });

    map.on('draw:drawstop', function (e) {
      drawIsActive = false;
    });

    map.on('draw:edited', function (e) {
        // draw:edited gets called after saving edition, BUT before draw:editstop
        //(i.e. draw:editstop is called after both save and cancel edit).
        // So our custom logic that we want to implement after saving edition
        // should go in draw:editstop.

        isEditionSaved = true;
    });

    map.on('draw:editstop', function (e) {
        // If edition is saved do the checking process,
        // if not (i.e. canceled ) just pass.
        if (isEditionSaved == true) {
            var layers = drawnItems.getLayers();  // Layers list.
            var polygons = get_cleaned_polygons(layers);

            var result = check_after_drawing(polygons);
            var trouble_polygons = result.trouble_polygons;
            var error_messages = result.error_messages;

            // Set "error" color to trouble polygons and default color to
            // regular polygons.
            var polygon_counter = 0;

            for (var key in drawnItems._layers) {
                if($.inArray(polygon_counter, trouble_polygons) != -1) {
                    drawnItems._layers[key].setStyle({
                        fillColor: '#ca4c4d',
                        color: '#ca4c4d'
                    });
                } else {
                    // Set default color.
                    drawnItems._layers[key].setStyle({
                        fillColor: '#FFA500',
                        color: '#FFA500'
                    });
                }

                polygon_counter++;
            }

            // Dump geojson to textarea.
            var geojson_string = create_geojson_multipolygon_string();
            $('#id_area_of_interest').val(geojson_string);

            if (trouble_polygons.length == 0) {
                // Empty multipolygon errors field.
                $('#id_multipolygon_errors').val('');
            } else {
                // Put multipolygon errors text in textarea.
                error_string = '';

                jQuery.each(error_messages, function() {
                    error_string += this + ' ';
                });

                $('#id_multipolygon_errors').val(error_string);

                // Show error tooltip.
                show_custom_tooltip(error_string);
            }
        }

        isEditionSaved = false;
    });

    map.on('draw:deleted', function (e) {
        var layers = drawnItems.getLayers();  // Layers list.
        var polygons = get_cleaned_polygons(layers);

        var result = check_after_drawing(polygons);
        var trouble_polygons = result.trouble_polygons;
        var error_messages = result.error_messages;

        // Set "error" color to trouble polygons and default color to
        // regular polygons.
        var polygon_counter = 0;

        for (var key in drawnItems._layers) {
            if($.inArray(polygon_counter, trouble_polygons) != -1) {
                drawnItems._layers[key].setStyle({
                    fillColor: '#ca4c4d',
                    color: '#ca4c4d'
                });
            } else {
                // Set default color.
                drawnItems._layers[key].setStyle({
                    fillColor: '#FFA500',
                    color: '#FFA500'
                });
            }

            polygon_counter++;
        }

        if (layers.length == 0) {
            // Empty area_of_interest text area.
            $('#id_area_of_interest').val('');
            // Empty multipolygon errors field.
            $('#id_multipolygon_errors').val('');
        } else {
            // Dump geojson to textarea.
            var geojson_string = create_geojson_multipolygon_string();
            $('#id_area_of_interest').val(geojson_string);

            if (trouble_polygons.length == 0) {
                // Empty multipolygon errors field.
                $('#id_multipolygon_errors').val('');
            } else {
                // Put multipolygon errors text in textarea.
                error_string = '';

                jQuery.each(error_messages, function() {
                    error_string += this + ' ';
                });

                $('#id_multipolygon_errors').val(error_string);

                // Show error tooltip.
                show_custom_tooltip(error_string);
            }
        }
    });

    map.on('click', function(e) {
        // If drawing is activated check if new point is inside existing polygon or
        // new line segment intersects with any of the existing line segments.
        if (drawIsActive == true) {
            current_point = [e.layerPoint.x, e.layerPoint.y];
            var layers = drawnItems.getLayers();

            // If other polygons exist then go through the checking process.
            if (layers.length > 0) {
                polygons = get_cleaned_polygons(layers)

                // Check if current point is inside existing polygon,
                // (important only for the first point of polygon).
                // For each polygon check if current line segment intersects
                // any line segement of the polygon.
                jQuery.each(polygons, function() {
                    // If previous_point exists (means that line segment exists)
                    // check intersections.
                    if (previous_point) {
                        var p1 = {x: previous_point[0], y: previous_point[1]};
                        var p2 = {x: current_point[0], y: current_point[1]};

                        for (i=0, j=this.length-1;i<this.length; j=i++) {
                            var p3 = {x: this[i][0], y: this[i][1]};
                            var p4 = {x: this[j][0], y: this[j][1]};

                            var intersects = L.LineUtil.segmentsIntersect(p1, p2, p3, p4);

                            if (intersects == true) {
                                // Programatically click link to delete the last vertex.
                                $('.leaflet-draw-actions li a:first')[0].click();
                                // Revert value of current_point to previous_point.
                                current_point = previous_point;
                                // Show error tooltip.
                                show_custom_tooltip("Area shouldn't intersect with another area.")
                                return false; // break jquery each loop and current loop
                            }
                        }
                    } else {
                        var pointIsInPolygon = point_in_polygon(current_point, this);

                        // If current point is inside existing polygon then delete
                        // that point and show error message.
                        if (pointIsInPolygon == true) {
                            // Programatically click link to delete created vertex.
                            $('.leaflet-draw-actions li a:eq(1)')[0].click();
                            // Show error tooltip.
                            show_custom_tooltip("Can't place point inside polygon.")
                            return false; // break jquery each loop
                        }
                    }
                });
            }
            // Set value of previous point to current_point for future.
            previous_point = current_point;
        }
    });

    map.on('mousemove', function(e) {
        if (errorShown) {
            custom_tooltip.updatePosition(e.latlng);
        }
    });

    // When link for drawing polygon is clicked then add event listener for 'cancel' link.
    $('.leaflet-draw-section .leaflet-draw-toolbar a:eq(0)').on('click', function() {
          // When cancel drawing link is clicked (either programatically or manually)
          // reset value of current point and previous point.
          $('.leaflet-draw-actions li a:eq(1)').on('click', function() {
              current_point = null;
              previous_point = null;
          });
    });

    function check_after_drawing(polygons) {
        var trouble_polygons = [];
        var error_messages = [];

        // Check if any polygon intersects any other polygon.
        // Check if any polygon covers any other polygon.
        // Check if polygon intersects itself. Leaflet Draw plugin does that
        // check during drawing, but not after polygons are edited.
        jQuery.each(polygons, function(index_a, poly_a) {

            jQuery.each(polygons, function(index_b, poly_b) {

                if (poly_b != poly_a) {

                    var result = polygon_intersects_polygon(
                                    error_messages, trouble_polygons,
                                    poly_a, index_a,
                                    poly_b, index_b);

                    trouble_polygons = result.trouble_polygons;
                    error_messages = result.error_messages;

                    var result = polygon_covers_polygon(
                                    error_messages, trouble_polygons,
                                    poly_a, index_a,
                                    poly_b, index_b);

                    trouble_polygons = result.trouble_polygons;
                    error_messages = result.error_messages;
                }
            });

            var result = polygon_intersects_itself(
                            error_messages, trouble_polygons,
                            poly_a, index_a);

            trouble_polygons = result.trouble_polygons;
            error_messages = result.error_messages;
        });

        return {
            trouble_polygons: trouble_polygons,
            error_messages: error_messages
        }
    }

    // Check if any line segment of any polygon intersects with any line
    // segment of any other polygon.
    function polygon_intersects_polygon(error_messages, trouble_polygons, poly_a, index_a, poly_b, index_b) {
        var error_message = "Area shouldn't intersect with another area.";

        for (var k = 0, h = poly_a.length - 1; k < poly_a.length; h = k++) {
            var p_1a = {x: poly_a[k][0], y: poly_a[k][1]};
            var p_2a = {x: poly_a[h][0], y: poly_a[h][1]};

            for (var e = 0, f = poly_b.length - 1; e < poly_b.length; f = e++) {
                var p_1b = {x: poly_b[e][0], y: poly_b[e][1]};
                var p_2b = {x: poly_b[f][0], y: poly_b[f][1]};

                var intersects = L.LineUtil.segmentsIntersect(p_1a, p_2a, p_1b, p_2b);

                if (intersects == true) {
                    if( $.inArray(index_a, trouble_polygons) == -1 ) {
                        trouble_polygons.push(index_a);
                    }

                    if ($.inArray(index_b, trouble_polygons) == -1 ) {
                        trouble_polygons.push(index_b);
                    }

                    if ($.inArray(error_message, error_messages) == -1 ) {
                        error_messages.push(error_message);
                    }
                }
            }
        }

        return {
            trouble_polygons: trouble_polygons,
            error_messages: error_messages
        }
    }

    // Check if any polygon covers any other polygon. We're actually checking
    // if point from one polygon lies inside another polygon.
    function polygon_covers_polygon(error_messages, trouble_polygons, poly_a, index_a, poly_b, index_b) {
        var error_message = "Area shouldn't cover another area.";

        jQuery.each(poly_a, function(point_index, point) {
            var pointIsInPolygon = point_in_polygon(point, poly_b);

            if (pointIsInPolygon == true) {
                if( $.inArray(index_a, trouble_polygons) == -1 ) {
                    trouble_polygons.push(index_a);
                }

                if( $.inArray(index_b, trouble_polygons) == -1 ) {
                    trouble_polygons.push(index_b);
                }

                if ($.inArray(error_message, error_messages) == -1 ) {
                    error_messages.push(error_message);
                }
            }
        });

        return {
            trouble_polygons: trouble_polygons,
            error_messages: error_messages
        }
    }

    function polygon_intersects_itself(error_messages, trouble_polygons, poly_a, index_a) {
        var error_message = "Area shouldn't intersect with itself.";

        for (var i = 0, j = poly_a.length - 1; i < poly_a.length; j = i++) {
            var p_1 = {x: poly_a[i][0], y: poly_a[i][1]}
            var p_2 = {x: poly_a[j][0], y: poly_a[j][1]}

            for (var k = 0, h = poly_a.length - 1; k < poly_a.length; h = k++) {
                var p_3 = {x: poly_a[h][0], y: poly_a[h][1]}
                var p_4 = {x: poly_a[k][0], y: poly_a[k][1]}

                if (p_3 != p_1 && p_4 != p_2) {
                    var intersects = L.LineUtil.segmentsIntersect(p_1, p_2, p_3, p_4);

                    if (intersects == true) {
                        if( $.inArray(index_a, trouble_polygons) == -1 ) {
                            trouble_polygons.push(index_a);
                        }

                        if ($.inArray(error_message, error_messages) == -1 ) {
                            error_messages.push(error_message);
                        }
                    }
                }
            }
        }

        return {
            trouble_polygons: trouble_polygons,
            error_messages: error_messages
        }
    }

    // Function that checks if point is inside polygon.
    function point_in_polygon (point, polygon) {
        var x = point[0], y = point[1];

        var inside = false;
        for (var i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
            var xi = polygon[i][0], yi = polygon[i][1];
            var xj = polygon[j][0], yj = polygon[j][1];

            var intersect = ((yi > y) != (yj > y))
                && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
            if (intersect) inside = !inside;
        }
        return inside;
    }

    function get_cleaned_polygons(layers) {
        var polygons = [];

        // For each layer (polygon) get it's points coords. in pixels.
        jQuery.each(layers, function () {
            var polygon_points = this._originalPoints;
            var clean_polygon_points = [];

            jQuery.each(polygon_points, function() {
                clean_polygon_points.push([this.x, this.y]);
            });

            polygons.push(clean_polygon_points);
        });

        return polygons;
    }

    function create_geojson_multipolygon_string() {
        var geojson_string = '{"type": "MultiPolygon","coordinates": [';

        for (var key in drawnItems._layers) {
            var layer = drawnItems._layers[key];
            geojson_string += JSON.stringify(layer.toGeoJSON()['geometry']['coordinates']) + ',';
        }

        geojson_string = geojson_string.slice(0, -1);  // remove last comma.
        geojson_string += ']}';  // finish geojson string.

        return geojson_string
    }

    function create_geojson_polygon_string() {
        var geojson_string = '{"type": "Polygon","coordinates": [';
    }

  </script>
{% endblock %}